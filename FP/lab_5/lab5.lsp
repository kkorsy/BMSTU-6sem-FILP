;; 1. Функция, которая уменьшает на 10 все числа из списка-аргумента этой функции, проходя по верхнему уровню списковых ячеек (список смешанный структурированный)
(defun minus10-list(lst)
    (mapcar #'(lambda(x) 
                    (if (numberp x) (- x 10) x)) lst))

;; 2. Функция, которая получает как аргумент список чисел, а возвращает список квадратов этих чисел в том же порядке
(defun square-list(lst)
    (mapcar #'(lambda(x) (* x x)) lst))

;; 3. Функция, которая умножает на заданное число-аргумент все числа из заданного списка-аргумента, когда
;;      а) все элементы списка --- числа
(defun multiply-list(lst num)
    (mapcar #'(lambda(x) (* num x)) lst))

;;      б) элементы списка --- любые объекты
(defun multiply-list-common(lst num)
    (mapcar #'(lambda(x) 
                    (if (numberp x) (* x num) x)) lst))

;; 4. Функция, которая по своему списку-аргументу определяет является ли он палиндромом, для одноуровнего смешанного списка
(defun is-palindrom(lst)
    (every #'(lambda(x) x) 
            (mapcar #'(lambda(x y) (eql x y)) 
                        lst (reverse lst))))

;; 5. Используя функционалы, написать предикат set-equal, который возвращает Т, если 2 его множества-аргумента (одноуровневые списки) содержат одни и те же элементы, порядок которых не имеет значения
(defun set-equal(set1 set2)
    (every #'(lambda(x) (= x 1))    
            (mapcar #'(lambda(el) (if (member el set2) 1 0)) 
                    set1)))

;; 6. Функция select-between, которая из списка-аргумента, содержащего только числа, выбирает только те, которые расположены между двумя указанными числами --- границами-аргументами и возвращает их в виде списка (доп: упорядоченного по возрастанию)
(defun sort-list(lst)
    (let ((temp 0))
         (maplist #'(lambda(x)
                (and (setf temp (apply #'min x)) 
                     (setf (car (member temp x)) (car x)) 
                     (setf (car x) temp))) lst)))

(defun select-between(x y lst)
    (sort-list (mapcan #'(lambda(el) (if (or (and (> x el) (< y el))
                                  (and (< x el) (> y el)))
                               (cons el ())
                               ())) lst)))

;; 7. Функция, вычисляющая декартово произведение двух своих списков-аргументов
(defun decart(lstX lstY)
    (mapcan #'(lambda(x)
                (mapcar #'(lambda(y) (list x y)) lstY))
                        lstX))

;; 8. Почему так реализовано reduce, в чем причина?
(reduce #'+ ())     ;; --> 0
(reduce #'* ())     ;; --> 1
;; Потому что reduce применяет первый аргумент к элементам второго аргумента-списка каскадным образом. Так как списки пустые, reduce возвращает начальное значение --- в данном случае нейтральный элемент по сложению и умножению

;; 9. Функция, которая вычисляет сумму длин всех элементов списка, состоящего из списков (количество атомов)
(defun len-list-of-lists(lst)
    (apply #'+ (mapcar #'(lambda(el)
                            (length el)) lst)))
